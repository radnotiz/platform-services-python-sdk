# coding: utf-8

# (C) Copyright IBM Corp. 2022.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# IBM OpenAPI SDK Code Generator Version: 3.54.1-1d9808a7-20220817-143039
 
"""
No description provided (generated by Openapi Generator
https://github.com/openapitools/openapi-generator)

API Version: 1.1.2
"""

from enum import Enum
from typing import Dict, List
import json

from ibm_cloud_sdk_core import BaseService, DetailedResponse
from ibm_cloud_sdk_core.authenticators.authenticator import Authenticator
from ibm_cloud_sdk_core.get_authenticator import get_authenticator_from_environment
from ibm_cloud_sdk_core.utils import convert_model

from .common import get_sdk_headers

##############################################################################
# Service
##############################################################################

class PartnerCenterSellV1(BaseService):
    """The Partner Center Sell V1 service."""

    DEFAULT_SERVICE_URL = 'https://product-lifecycle.api.cloud.ibm.com/openapi/v1'
    DEFAULT_SERVICE_NAME = 'partner_center_sell'

    @classmethod
    def new_instance(cls,
                     service_name: str = DEFAULT_SERVICE_NAME,
                    ) -> 'PartnerCenterSellV1':
        """
        Return a new client for the Partner Center Sell service using the specified
               parameters and external configuration.
        """
        authenticator = get_authenticator_from_environment(service_name)
        service = cls(
            authenticator
            )
        service.configure_service(service_name)
        return service

    def __init__(self,
                 authenticator: Authenticator = None,
                ) -> None:
        """
        Construct a new client for the Partner Center Sell service.

        :param Authenticator authenticator: The authenticator specifies the authentication mechanism.
               Get up to date information from https://github.com/IBM/python-sdk-core/blob/main/README.md
               about initializing the authenticator of your choice.
        """
        BaseService.__init__(self,
                             service_url=self.DEFAULT_SERVICE_URL,
                             authenticator=authenticator)


    #########################
    # Products
    #########################


    def list_products(self,
        **kwargs
    ) -> DetailedResponse:
        """
        List products.

        List all available products that are onboarded to Partner Center Sell.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ListProductsResponse` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_products')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/products'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def create_product(self,
        product_name: str,
        tax_assessment: str,
        product_type: str,
        *,
        material_agreement: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Create product.

        Start to onboard a new product to Partner Center Sell.

        :param str product_name: The name of the product that you are onboarding.
               This name is displayed to users when you publish your product in the
               catalog.
        :param str tax_assessment: The tax assessment for your product.
        :param str product_type: The type of the product that you want to onboard
               to IBM Cloud.
        :param bool material_agreement: (optional) The confirmation that your
               company is authorized to use all materials.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ProductDetails` object
        """

        if product_name is None:
            raise ValueError('product_name must be provided')
        if tax_assessment is None:
            raise ValueError('tax_assessment must be provided')
        if product_type is None:
            raise ValueError('product_type must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='create_product')
        headers.update(sdk_headers)

        data = {
            'productName': product_name,
            'taxAssessment': tax_assessment,
            'productType': product_type,
            'materialAgreement': material_agreement
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/products'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def get_product(self,
        product_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get product details.

        Retrieve available details of a product. Details include contact information,
        product type, and private catalog ID.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ProductDetails` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_product')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def update_product(self,
        product_id: str,
        *,
        material_agreement: bool = None,
        product_name: str = None,
        tax_assessment: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Update product details.

        Update a product's name, tax assessment, and material agreement.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param bool material_agreement: (optional) The confirmation that your
               company is authorized to use all materials.
        :param str product_name: (optional) The name of the product that you are
               onboarding. This name is displayed to users when you publish your product
               in the catalog.
        :param str tax_assessment: (optional) The tax assessment for your product.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ProductDetails` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='update_product')
        headers.update(sdk_headers)

        data = {
            'materialAgreement': material_agreement,
            'productName': product_name,
            'taxAssessment': tax_assessment
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def delete_product(self,
        product_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete a draft product.

        Delete a product that is not published to the IBM Cloud catalog or shared with
        other accounts. To remove a published or shared product from your account, you
        must first deprecate the product.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `bool` result
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='delete_product')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def publish_product(self,
        product_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Publish an approved product.

        To publish a product to the IBM Cloud catalog, you must submit for approval. After
        you receive approval, you can publish to the catalog.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ProductDetails` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='publish_product')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/publish'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def suspend_product(self,
        product_id: str,
        reason: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Suspend a published product.

        You can remove a product from the IBM Cloud catalog without permanently deleting
        or deprecating it for up to 7 days. You might want to suspend a product if you
        discover a bug or vulnerability that must be investigated and fixed.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str reason: The reason why you want to suspend your published
               product.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ProductDetails` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if reason is None:
            raise ValueError('reason must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='suspend_product')
        headers.update(sdk_headers)

        data = {
            'reason': reason
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/suspend'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def deprecate_product(self,
        product_id: str,
        reason: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Deprecate a published product.

        If you need to permanently delete your product or a version from the IBM Cloud
        catalog, deprecate it first. Your product remains available for use during a
        90-day deprecation period, and is removed after 90 days.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str reason: The reason why you want to deprecate your published
               product.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ProductDetails` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if reason is None:
            raise ValueError('reason must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='deprecate_product')
        headers.update(sdk_headers)

        data = {
            'reason': reason
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/deprecate'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def restore_product(self,
        product_id: str,
        reason: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Restore a deprecated product.

        If your product is deprecated, you have 90 days to restore it to keep it in the
        catalog.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str reason: The reason why you want to restore your deprecated
               product.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ProductDetails` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if reason is None:
            raise ValueError('reason must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='restore_product')
        headers.update(sdk_headers)

        data = {
            'reason': reason
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/restore'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def list_badges(self,
        **kwargs
    ) -> DetailedResponse:
        """
        List badges.

        List all available badges a product can be validated against.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CloudBadge` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_badges')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        url = '/products/badges'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def get_badge(self,
        badge_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get badge.

        Get a badge by id.

        :param str badge_id: The unique ID of the badge. This ID can be obtained by
               calling the list badges method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CloudBadge` object
        """

        if badge_id is None:
            raise ValueError('badge_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_badge')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['badgeId']
        path_param_values = self.encode_path_vars(badge_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/badges/{badgeId}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response

    #########################
    # Catalog
    #########################


    def get_catalog(self,
        product_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        View a product's catalog data.

        View the catalog entry details and other data that is stored for your product.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CatalogListingDetails` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_catalog')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/catalog'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def update_catalog(self,
        product_id: str,
        *,
        catalog_id: str = None,
        description: str = None,
        icon_url: str = None,
        keywords: List[str] = None,
        pricing_model: str = None,
        category: str = None,
        provider_type: List[str] = None,
        label: str = None,
        name: str = None,
        provider: str = None,
        tags: List[str] = None,
        documentation_url: str = None,
        highlights: List['HighlightSectionInput'] = None,
        long_description: str = None,
        media: List['MediaSectionInput'] = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Update a product's catalog data.

        Update the catalog entry details and other data that is stored for your product.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str catalog_id: (optional) The ID of the private catalog where your
               products are created.
        :param str description: (optional) The description of the product.
        :param str icon_url: (optional) The URL for your company or product logo.
        :param List[str] keywords: (optional) The key search terms that are
               associated with your product.
        :param str pricing_model: (optional) The pricing model for your product.
        :param str category: (optional) A list of values that are used to
               categorize products in the catalog. By using the Catalogs management CLI
               plug-in, run the `ibmcloud catalog offering category-options` CLI command
               to list all possible values.
        :param List[str] provider_type: (optional)
        :param str label: (optional) The name of the product.
        :param str name: (optional) The name of the product.
        :param str provider: (optional) The name of your company.
        :param List[str] tags: (optional) The keywords and phrases that are
               associated with your product.
        :param str documentation_url: (optional) The link to the warranted product
               documentation.
        :param List[HighlightSectionInput] highlights: (optional) The attributes of
               the product that differentiate it in the market.
        :param str long_description: (optional) The description about the details
               of the product. You can use markdown syntax to provide this description.
        :param List[MediaSectionInput] media: (optional) The images or videos that
               show off the product.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CatalogListingDetails` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if highlights is not None:
            highlights = [convert_model(x) for x in highlights]
        if media is not None:
            media = [convert_model(x) for x in media]
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='update_catalog')
        headers.update(sdk_headers)

        data = {
            'catalogId': catalog_id,
            'description': description,
            'iconUrl': icon_url,
            'keywords': keywords,
            'pricingModel': pricing_model,
            'category': category,
            'providerType': provider_type,
            'label': label,
            'name': name,
            'provider': provider,
            'tags': tags,
            'documentationUrl': documentation_url,
            'highlights': highlights,
            'longDescription': long_description,
            'media': media
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/catalog'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def request_catalog_approval(self,
        product_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Request a catalog listing approval.

        If a catalog listing was not approved for publishing during the initial product
        approval process, you can request approval again.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Resource` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='request_catalog_approval')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/catalog/approvals'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response

    #########################
    # Pricing
    #########################


    def list_plans(self,
        product_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        List pricing plans that are connected to a product.

        List pricing plans that are connected to a product.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ListPlansResponse` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_plans')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/plans'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def create_plan(self,
        product_id: str,
        description: str,
        label: str,
        type: str,
        url: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Create a pricing plan.

        Define how you want to charge users for your product. If you aren't sure how you
        want charge users, you can start by using a free plan.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str description: The description of the pricing model.
        :param str label: The name of the pricing plan.
        :param str type: The type of the pricing plan.
        :param str url: The URL to where your customers can purchase the license
               that is required to use your product.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CreatePlanResponse` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if description is None:
            raise ValueError('description must be provided')
        if label is None:
            raise ValueError('label must be provided')
        if type is None:
            raise ValueError('type must be provided')
        if url is None:
            raise ValueError('url must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='create_plan')
        headers.update(sdk_headers)

        data = {
            'description': description,
            'label': label,
            'type': type,
            'url': url
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/plans'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def get_plan(self,
        product_id: str,
        pricing_plan_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get pricing plan by ID.

        Use the pricing plan ID to retrieve its details.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str pricing_plan_id: The resource ID of the pricing plan. This ID
               can be obtained by listing pricing plans.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `License` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if pricing_plan_id is None:
            raise ValueError('pricing_plan_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_plan')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId', 'pricingPlanId']
        path_param_values = self.encode_path_vars(product_id, pricing_plan_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/plans/{pricingPlanId}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def update_plan(self,
        product_id: str,
        pricing_plan_id: str,
        description: str,
        label: str,
        type: str,
        url: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Update a pricing plan.

        If you need to change details of a pricing plan, such as the name, description,
        URL, or type, you can update the pricing plan. After your changes are submitted
        for a published product, the changes are displayed in the catalog.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str pricing_plan_id: The resource ID of the pricing plan. This ID
               can be obtained by listing pricing plans.
        :param str description: The description of the pricing model.
        :param str label: The name of the pricing plan.
        :param str type: The type of the pricing plan.
        :param str url: The URL to where your customers can purchase the license
               that is required to use your product.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CreatePlanResponse` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if pricing_plan_id is None:
            raise ValueError('pricing_plan_id must be provided')
        if description is None:
            raise ValueError('description must be provided')
        if label is None:
            raise ValueError('label must be provided')
        if type is None:
            raise ValueError('type must be provided')
        if url is None:
            raise ValueError('url must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='update_plan')
        headers.update(sdk_headers)

        data = {
            'description': description,
            'label': label,
            'type': type,
            'url': url
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId', 'pricingPlanId']
        path_param_values = self.encode_path_vars(product_id, pricing_plan_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/plans/{pricingPlanId}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def delete_plan(self,
        product_id: str,
        pricing_plan_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete a pricing plan.

        If you need to remove a pricing plan for a product, you can delete it.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str pricing_plan_id: The resource ID of the pricing plan. This ID
               can be obtained by listing pricing plans.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CreatePlanResponse` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if pricing_plan_id is None:
            raise ValueError('pricing_plan_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='delete_plan')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId', 'pricingPlanId']
        path_param_values = self.encode_path_vars(product_id, pricing_plan_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/plans/{pricingPlanId}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response

    #########################
    # Support
    #########################


    def get_support(self,
        product_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get product support details.

        View the product support details, including the contacts and the escalation
        process.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Support` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_support')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/support'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def update_support(self,
        product_id: str,
        *,
        escalation_contacts: List['EscalationContactsUpdate'] = None,
        locations: List[str] = None,
        support_details: List['SupportDetails'] = None,
        support_escalation: 'SupportEscalation' = None,
        support_type: str = None,
        url: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Update product support details.

        Update the product support details, including the contacts and the escalation
        process.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param List[EscalationContactsUpdate] escalation_contacts: (optional) The
               direct contact for IBM Cloud Support leaders to communicate with the
               support leader of your product. This contact information is not displayed
               on the product detail page in the catalog.
        :param List[str] locations: (optional) The locations where support is
               provided from.
        :param List[SupportDetails] support_details: (optional) Provide details
               about the available options for getting support. The details that you
               provide are displayed on your product details page in the catalog.
        :param SupportEscalation support_escalation: (optional) The details about
               your support escalation process. The details that you provide are displayed
               on your product details page in the catalog.
        :param str support_type: (optional) The provider type for support of your
               product.
        :param str url: (optional) The support site URL where users can go to get
               help, answer their questions, or ask experts and the community for help.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Support` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if escalation_contacts is not None:
            escalation_contacts = [convert_model(x) for x in escalation_contacts]
        if support_details is not None:
            support_details = [convert_model(x) for x in support_details]
        if support_escalation is not None:
            support_escalation = convert_model(support_escalation)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='update_support')
        headers.update(sdk_headers)

        data = {
            'escalationContacts': escalation_contacts,
            'locations': locations,
            'support_details': support_details,
            'support_escalation': support_escalation,
            'support_type': support_type,
            'url': url
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/support'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def list_support_change_requests(self,
        product_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        List all change requests related to a given product.

        List all change requests related to a given product.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ListSupportChangeRequestsResponse` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_support_change_requests')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/support/changes'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def create_support_change_request(self,
        product_id: str,
        change: 'Support',
        **kwargs
    ) -> DetailedResponse:
        """
        Update support data of an already approved or published product.

        To update the support data of an already approved or published product, your
        changes will be required to be reviewed and approved. To do updates on a published
        product, you have to open a change request, add your changes to it, then request a
        review for your changes. Once the changes are approved, you can merge these
        updates to your published product.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param Support change: Provide details about how customers can get help
               when they are using your product.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ProductDetails` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if change is None:
            raise ValueError('change must be provided')
        change = convert_model(change)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='create_support_change_request')
        headers.update(sdk_headers)

        data = {
            'change': change
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/support/changes'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def get_support_change_request(self,
        product_id: str,
        change_request_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get a change request related to a given product by id.

        Get a change request related to a given product by id.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str change_request_id: The resource ID of the change request. This
               ID can be obtained by getting the offering and finding the current change
               request on it.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ChangeRequest` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if change_request_id is None:
            raise ValueError('change_request_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='get_support_change_request')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId', 'changeRequestId']
        path_param_values = self.encode_path_vars(product_id, change_request_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/support/changes/{changeRequestId}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def update_support_change_request(self,
        product_id: str,
        change_request_id: str,
        change: 'Support',
        **kwargs
    ) -> DetailedResponse:
        """
        Update an already created change request.

        Update a change request that was created earlier.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str change_request_id: The resource ID of the change request. This
               ID can be obtained by getting the offering and finding the current change
               request on it.
        :param Support change: Provide details about how customers can get help
               when they are using your product.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ProductDetails` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if change_request_id is None:
            raise ValueError('change_request_id must be provided')
        if change is None:
            raise ValueError('change must be provided')
        change = convert_model(change)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='update_support_change_request')
        headers.update(sdk_headers)

        data = {
            'change': change
        }
        data = {k: v for (k, v) in data.items() if v is not None}
        data = json.dumps(data)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId', 'changeRequestId']
        path_param_values = self.encode_path_vars(product_id, change_request_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/support/changes/{changeRequestId}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request, **kwargs)
        return response


    def list_support_change_request_reviews(self,
        product_id: str,
        change_request_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        List review events related to a change request.

        List review events related to a change request.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str change_request_id: The resource ID of the change request. This
               ID can be obtained by getting the offering and finding the current change
               request on it.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Resource` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if change_request_id is None:
            raise ValueError('change_request_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_support_change_request_reviews')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId', 'changeRequestId']
        path_param_values = self.encode_path_vars(product_id, change_request_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/support/changes/{changeRequestId}/reviews'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def request_support_change_request_review(self,
        product_id: str,
        change_request_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Update an already created change request.

        Update a change request that was created earlier.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str change_request_id: The resource ID of the change request. This
               ID can be obtained by getting the offering and finding the current change
               request on it.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Resource` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if change_request_id is None:
            raise ValueError('change_request_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='request_support_change_request_review')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId', 'changeRequestId']
        path_param_values = self.encode_path_vars(product_id, change_request_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/support/changes/{changeRequestId}/reviews'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def merge_support_change_request(self,
        product_id: str,
        change_request_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Merge the approved changeset to the published product.

        Merge the approved change request back to the published product to make the
        changes available publicly.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param str change_request_id: The resource ID of the change request. This
               ID can be obtained by getting the offering and finding the current change
               request on it.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ProductDetails` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        if change_request_id is None:
            raise ValueError('change_request_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='merge_support_change_request')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId', 'changeRequestId']
        path_param_values = self.encode_path_vars(product_id, change_request_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/support/changes/{changeRequestId}/merge'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def request_support_approval(self,
        product_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Request approval of support information.

        If the support information for your product is not approved, you can use this
        method to request approval of your product's support information again.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Resource` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='request_support_approval')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/support/approvals'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response

    #########################
    # Approval
    #########################


    def request_product_approval(self,
        product_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Request approval to publish.

        After you complete the requirements for onboarding a product, you can request
        approval to publish to the IBM Cloud catalog.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Resource` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='request_product_approval')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/approvals'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


    def list_product_approvals(self,
        product_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        List approvals.

        By using the product ID, you can get the current state and history of all
        approvals. Approvals are required to publish your product to the catalog.

        :param str product_id: The unique ID of the product. This ID can be
               obtained by calling the list products method and also can be found in
               Partner Center.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ListProductApprovalsResponse` object
        """

        if product_id is None:
            raise ValueError('product_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V1',
                                      operation_id='list_product_approvals')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
            del kwargs['headers']
        headers['Accept'] = 'application/json'

        path_param_keys = ['productId']
        path_param_values = self.encode_path_vars(product_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/products/{productId}/approvals'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request, **kwargs)
        return response


##############################################################################
# Models
##############################################################################


class CatalogListingDetails():
    """
    CatalogListingDetails.

    :attr str account_id: (optional) The unique ID for the account in which the
          product is being onboarded.
    :attr str catalog_id: The ID of the private catalog where your products are
          created.
    :attr DeprecatePending deprecate_pending: (optional) The deprecation process of
          the product is in the pending state.
    :attr str description: (optional) The description of the product.
    :attr str documentation_url: (optional) The link to the warranted product
          documentation.
    :attr bool editable: (optional) The product can be edited.
    :attr List[HighlightSection] highlights: (optional) The attributes of the
          product that differentiate it in the market.
    :attr str icon_url: (optional) The URL for your company or product logo.
    :attr str id: The ID that uniquely identifies the product in Partner Center.
          This ID can be found on the Dashboard tab in Partner Center.
    :attr List[str] keywords: (optional) The key search terms that are associated
          with your product.
    :attr str label: (optional) The name of the product.
    :attr object label_i18n: (optional) Translated strings for the name of the
          product.
    :attr str long_description: (optional) The description about the details of the
          product. You can use markdown syntax to provide this description.
    :attr object long_description_i18n: (optional) Translated strings for describing
          the details of the product. You can use markdown syntax to provide this
          description.
    :attr List[MediaSection] media: (optional) The images or videos that show off
          the product.
    :attr str name: (optional) The name of the product.
    :attr bool pc_managed: (optional) The product was created in Partner Center.
    :attr str provider: (optional) The name of your company.
    :attr bool published_to_access_list: (optional) The product is published to an
          access list. An access list is a list of accounts that your product is
          potentially shared with.
    :attr bool published_to_ibm: (optional) The product is available to all IBMers.
    :attr bool published_to_public: (optional) The product is published to the IBM
          Cloud catalog.
    :attr object short_description_i18n: (optional) Translated strings for the
          description of the product.
    :attr List[str] tags: (optional) The keywords and phrases that are associated
          with your product.
    :attr List[CatalogListingVersion] versions: (optional) The version details of a
          product.
    """

    def __init__(self,
                 catalog_id: str,
                 id: str,
                 *,
                 account_id: str = None,
                 deprecate_pending: 'DeprecatePending' = None,
                 description: str = None,
                 documentation_url: str = None,
                 editable: bool = None,
                 highlights: List['HighlightSection'] = None,
                 icon_url: str = None,
                 keywords: List[str] = None,
                 label: str = None,
                 label_i18n: object = None,
                 long_description: str = None,
                 long_description_i18n: object = None,
                 media: List['MediaSection'] = None,
                 name: str = None,
                 pc_managed: bool = None,
                 provider: str = None,
                 published_to_access_list: bool = None,
                 published_to_ibm: bool = None,
                 published_to_public: bool = None,
                 short_description_i18n: object = None,
                 tags: List[str] = None,
                 versions: List['CatalogListingVersion'] = None) -> None:
        """
        Initialize a CatalogListingDetails object.

        :param str catalog_id: The ID of the private catalog where your products
               are created.
        :param str id: The ID that uniquely identifies the product in Partner
               Center. This ID can be found on the Dashboard tab in Partner Center.
        :param str account_id: (optional) The unique ID for the account in which
               the product is being onboarded.
        :param DeprecatePending deprecate_pending: (optional) The deprecation
               process of the product is in the pending state.
        :param str description: (optional) The description of the product.
        :param str documentation_url: (optional) The link to the warranted product
               documentation.
        :param bool editable: (optional) The product can be edited.
        :param List[HighlightSection] highlights: (optional) The attributes of the
               product that differentiate it in the market.
        :param str icon_url: (optional) The URL for your company or product logo.
        :param List[str] keywords: (optional) The key search terms that are
               associated with your product.
        :param str label: (optional) The name of the product.
        :param object label_i18n: (optional) Translated strings for the name of the
               product.
        :param str long_description: (optional) The description about the details
               of the product. You can use markdown syntax to provide this description.
        :param object long_description_i18n: (optional) Translated strings for
               describing the details of the product. You can use markdown syntax to
               provide this description.
        :param List[MediaSection] media: (optional) The images or videos that show
               off the product.
        :param str name: (optional) The name of the product.
        :param bool pc_managed: (optional) The product was created in Partner
               Center.
        :param str provider: (optional) The name of your company.
        :param bool published_to_access_list: (optional) The product is published
               to an access list. An access list is a list of accounts that your product
               is potentially shared with.
        :param bool published_to_ibm: (optional) The product is available to all
               IBMers.
        :param bool published_to_public: (optional) The product is published to the
               IBM Cloud catalog.
        :param object short_description_i18n: (optional) Translated strings for the
               description of the product.
        :param List[str] tags: (optional) The keywords and phrases that are
               associated with your product.
        :param List[CatalogListingVersion] versions: (optional) The version details
               of a product.
        """
        self.account_id = account_id
        self.catalog_id = catalog_id
        self.deprecate_pending = deprecate_pending
        self.description = description
        self.documentation_url = documentation_url
        self.editable = editable
        self.highlights = highlights
        self.icon_url = icon_url
        self.id = id
        self.keywords = keywords
        self.label = label
        self.label_i18n = label_i18n
        self.long_description = long_description
        self.long_description_i18n = long_description_i18n
        self.media = media
        self.name = name
        self.pc_managed = pc_managed
        self.provider = provider
        self.published_to_access_list = published_to_access_list
        self.published_to_ibm = published_to_ibm
        self.published_to_public = published_to_public
        self.short_description_i18n = short_description_i18n
        self.tags = tags
        self.versions = versions

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CatalogListingDetails':
        """Initialize a CatalogListingDetails object from a json dictionary."""
        args = {}
        if 'accountId' in _dict:
            args['account_id'] = _dict.get('accountId')
        if 'catalogId' in _dict:
            args['catalog_id'] = _dict.get('catalogId')
        else:
            raise ValueError('Required property \'catalogId\' not present in CatalogListingDetails JSON')
        if 'deprecatePending' in _dict:
            args['deprecate_pending'] = DeprecatePending.from_dict(_dict.get('deprecatePending'))
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'documentationUrl' in _dict:
            args['documentation_url'] = _dict.get('documentationUrl')
        if 'editable' in _dict:
            args['editable'] = _dict.get('editable')
        if 'highlights' in _dict:
            args['highlights'] = [HighlightSection.from_dict(x) for x in _dict.get('highlights')]
        if 'iconUrl' in _dict:
            args['icon_url'] = _dict.get('iconUrl')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in CatalogListingDetails JSON')
        if 'keywords' in _dict:
            args['keywords'] = _dict.get('keywords')
        if 'label' in _dict:
            args['label'] = _dict.get('label')
        if 'label_i18n' in _dict:
            args['label_i18n'] = _dict.get('label_i18n')
        if 'longDescription' in _dict:
            args['long_description'] = _dict.get('longDescription')
        if 'long_description_i18n' in _dict:
            args['long_description_i18n'] = _dict.get('long_description_i18n')
        if 'media' in _dict:
            args['media'] = [MediaSection.from_dict(x) for x in _dict.get('media')]
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'pcManaged' in _dict:
            args['pc_managed'] = _dict.get('pcManaged')
        if 'provider' in _dict:
            args['provider'] = _dict.get('provider')
        if 'publishedToAccessList' in _dict:
            args['published_to_access_list'] = _dict.get('publishedToAccessList')
        if 'publishedToIBM' in _dict:
            args['published_to_ibm'] = _dict.get('publishedToIBM')
        if 'publishedToPublic' in _dict:
            args['published_to_public'] = _dict.get('publishedToPublic')
        if 'short_description_i18n' in _dict:
            args['short_description_i18n'] = _dict.get('short_description_i18n')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'versions' in _dict:
            args['versions'] = [CatalogListingVersion.from_dict(x) for x in _dict.get('versions')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CatalogListingDetails object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'account_id') and self.account_id is not None:
            _dict['accountId'] = self.account_id
        if hasattr(self, 'catalog_id') and self.catalog_id is not None:
            _dict['catalogId'] = self.catalog_id
        if hasattr(self, 'deprecate_pending') and self.deprecate_pending is not None:
            _dict['deprecatePending'] = self.deprecate_pending.to_dict()
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'documentation_url') and self.documentation_url is not None:
            _dict['documentationUrl'] = self.documentation_url
        if hasattr(self, 'editable') and self.editable is not None:
            _dict['editable'] = self.editable
        if hasattr(self, 'highlights') and self.highlights is not None:
            _dict['highlights'] = [x.to_dict() for x in self.highlights]
        if hasattr(self, 'icon_url') and self.icon_url is not None:
            _dict['iconUrl'] = self.icon_url
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'keywords') and self.keywords is not None:
            _dict['keywords'] = self.keywords
        if hasattr(self, 'label') and self.label is not None:
            _dict['label'] = self.label
        if hasattr(self, 'label_i18n') and self.label_i18n is not None:
            _dict['label_i18n'] = self.label_i18n
        if hasattr(self, 'long_description') and self.long_description is not None:
            _dict['longDescription'] = self.long_description
        if hasattr(self, 'long_description_i18n') and self.long_description_i18n is not None:
            _dict['long_description_i18n'] = self.long_description_i18n
        if hasattr(self, 'media') and self.media is not None:
            _dict['media'] = [x.to_dict() for x in self.media]
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'pc_managed') and self.pc_managed is not None:
            _dict['pcManaged'] = self.pc_managed
        if hasattr(self, 'provider') and self.provider is not None:
            _dict['provider'] = self.provider
        if hasattr(self, 'published_to_access_list') and self.published_to_access_list is not None:
            _dict['publishedToAccessList'] = self.published_to_access_list
        if hasattr(self, 'published_to_ibm') and self.published_to_ibm is not None:
            _dict['publishedToIBM'] = self.published_to_ibm
        if hasattr(self, 'published_to_public') and self.published_to_public is not None:
            _dict['publishedToPublic'] = self.published_to_public
        if hasattr(self, 'short_description_i18n') and self.short_description_i18n is not None:
            _dict['short_description_i18n'] = self.short_description_i18n
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'versions') and self.versions is not None:
            _dict['versions'] = [x.to_dict() for x in self.versions]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CatalogListingDetails object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CatalogListingDetails') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CatalogListingDetails') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CatalogListingVersion():
    """
    The version details of a product.

    :attr DeprecatePending deprecate_pending: (optional) The deprecation process of
          the product is in the pending state.
    :attr str id: The version ID of the product. This ID can be found by using the
          Catalog management API.
    :attr str kind_format: (optional) The content kind.
    :attr str kind_id: (optional) The unique ID of kind.
    :attr str kind_target: (optional) Target kinds.
    :attr str package_version: (optional) The version of the package.
    :attr str state: (optional) The state of the version of your product.
    :attr str state_change_time: (optional) The time when the state of the version
          changed.
    :attr str validated_state: (optional) The validation status of the version of
          your product.
    :attr str version: (optional) The version number of the current version.
    :attr str version_locator: (optional) A dot notation value that uses the format
          `catalogID.versionID`.
    :attr List[str] allowlisted_accounts: (optional) The list of allowlisted
          accounts that have access to the version of your product.
    """

    def __init__(self,
                 id: str,
                 *,
                 deprecate_pending: 'DeprecatePending' = None,
                 kind_format: str = None,
                 kind_id: str = None,
                 kind_target: str = None,
                 package_version: str = None,
                 state: str = None,
                 state_change_time: str = None,
                 validated_state: str = None,
                 version: str = None,
                 version_locator: str = None,
                 allowlisted_accounts: List[str] = None) -> None:
        """
        Initialize a CatalogListingVersion object.

        :param str id: The version ID of the product. This ID can be found by using
               the Catalog management API.
        :param DeprecatePending deprecate_pending: (optional) The deprecation
               process of the product is in the pending state.
        :param str kind_format: (optional) The content kind.
        :param str kind_id: (optional) The unique ID of kind.
        :param str kind_target: (optional) Target kinds.
        :param str package_version: (optional) The version of the package.
        :param str state: (optional) The state of the version of your product.
        :param str state_change_time: (optional) The time when the state of the
               version changed.
        :param str validated_state: (optional) The validation status of the version
               of your product.
        :param str version: (optional) The version number of the current version.
        :param str version_locator: (optional) A dot notation value that uses the
               format `catalogID.versionID`.
        :param List[str] allowlisted_accounts: (optional) The list of allowlisted
               accounts that have access to the version of your product.
        """
        self.deprecate_pending = deprecate_pending
        self.id = id
        self.kind_format = kind_format
        self.kind_id = kind_id
        self.kind_target = kind_target
        self.package_version = package_version
        self.state = state
        self.state_change_time = state_change_time
        self.validated_state = validated_state
        self.version = version
        self.version_locator = version_locator
        self.allowlisted_accounts = allowlisted_accounts

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CatalogListingVersion':
        """Initialize a CatalogListingVersion object from a json dictionary."""
        args = {}
        if 'deprecatePending' in _dict:
            args['deprecate_pending'] = DeprecatePending.from_dict(_dict.get('deprecatePending'))
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in CatalogListingVersion JSON')
        if 'kindFormat' in _dict:
            args['kind_format'] = _dict.get('kindFormat')
        if 'kindId' in _dict:
            args['kind_id'] = _dict.get('kindId')
        if 'kindTarget' in _dict:
            args['kind_target'] = _dict.get('kindTarget')
        if 'packageVersion' in _dict:
            args['package_version'] = _dict.get('packageVersion')
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'stateChangeTime' in _dict:
            args['state_change_time'] = _dict.get('stateChangeTime')
        if 'validatedState' in _dict:
            args['validated_state'] = _dict.get('validatedState')
        if 'version' in _dict:
            args['version'] = _dict.get('version')
        if 'versionLocator' in _dict:
            args['version_locator'] = _dict.get('versionLocator')
        if 'allowlistedAccounts' in _dict:
            args['allowlisted_accounts'] = _dict.get('allowlistedAccounts')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CatalogListingVersion object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'deprecate_pending') and self.deprecate_pending is not None:
            _dict['deprecatePending'] = self.deprecate_pending.to_dict()
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'kind_format') and self.kind_format is not None:
            _dict['kindFormat'] = self.kind_format
        if hasattr(self, 'kind_id') and self.kind_id is not None:
            _dict['kindId'] = self.kind_id
        if hasattr(self, 'kind_target') and self.kind_target is not None:
            _dict['kindTarget'] = self.kind_target
        if hasattr(self, 'package_version') and self.package_version is not None:
            _dict['packageVersion'] = self.package_version
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state
        if hasattr(self, 'state_change_time') and self.state_change_time is not None:
            _dict['stateChangeTime'] = self.state_change_time
        if hasattr(self, 'validated_state') and self.validated_state is not None:
            _dict['validatedState'] = self.validated_state
        if hasattr(self, 'version') and self.version is not None:
            _dict['version'] = self.version
        if hasattr(self, 'version_locator') and self.version_locator is not None:
            _dict['versionLocator'] = self.version_locator
        if hasattr(self, 'allowlisted_accounts') and self.allowlisted_accounts is not None:
            _dict['allowlistedAccounts'] = self.allowlisted_accounts
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CatalogListingVersion object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CatalogListingVersion') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CatalogListingVersion') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class KindTargetEnum(str, Enum):
        """
        Target kinds.
        """
        IKS = 'iks'
        ROKS = 'roks'
        VCENTER = 'vcenter'
        POWER_IAAS = 'power-iaas'
        TERRAFORM = 'terraform'


class ChangeRequest():
    """
    A change request that was opened to change the support properties of a published
    product.

    :attr str id: (optional) A unique id that identifies the change request.
    :attr str created_at: (optional) The time when the change request was created in
          standard ISO 8601 format.
    :attr str initiator: (optional) The user ID of the user who initiated this
          change request.
    :attr str merged: (optional) The time when the change request was merged back to
          the published product in standard ISO 8601 format.
    :attr Support change: (optional) Provide details about how customers can get
          help when they are using your product.
    """

    def __init__(self,
                 *,
                 id: str = None,
                 created_at: str = None,
                 initiator: str = None,
                 merged: str = None,
                 change: 'Support' = None) -> None:
        """
        Initialize a ChangeRequest object.

        :param str id: (optional) A unique id that identifies the change request.
        :param str created_at: (optional) The time when the change request was
               created in standard ISO 8601 format.
        :param str initiator: (optional) The user ID of the user who initiated this
               change request.
        :param str merged: (optional) The time when the change request was merged
               back to the published product in standard ISO 8601 format.
        :param Support change: (optional) Provide details about how customers can
               get help when they are using your product.
        """
        self.id = id
        self.created_at = created_at
        self.initiator = initiator
        self.merged = merged
        self.change = change

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ChangeRequest':
        """Initialize a ChangeRequest object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'createdAt' in _dict:
            args['created_at'] = _dict.get('createdAt')
        if 'initiator' in _dict:
            args['initiator'] = _dict.get('initiator')
        if 'merged' in _dict:
            args['merged'] = _dict.get('merged')
        if 'change' in _dict:
            args['change'] = Support.from_dict(_dict.get('change'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ChangeRequest object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['createdAt'] = self.created_at
        if hasattr(self, 'initiator') and self.initiator is not None:
            _dict['initiator'] = self.initiator
        if hasattr(self, 'merged') and self.merged is not None:
            _dict['merged'] = self.merged
        if hasattr(self, 'change') and self.change is not None:
            _dict['change'] = self.change.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ChangeRequest object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ChangeRequest') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ChangeRequest') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CloudBadge():
    """
    CloudBadge.

    :attr str id: The ID of the badge.
    :attr str label: (optional) The name of the badge.
    :attr str description: (optional) The description of the badge.
    :attr CloudBadgeLearnMoreLinks learn_more_links: (optional)
    :attr str get_started_link: (optional) An url to get started with the validation
          against this certification.
    :attr str tag: (optional) Deprecated, will be removed.
    """

    def __init__(self,
                 id: str,
                 *,
                 label: str = None,
                 description: str = None,
                 learn_more_links: 'CloudBadgeLearnMoreLinks' = None,
                 get_started_link: str = None,
                 tag: str = None) -> None:
        """
        Initialize a CloudBadge object.

        :param str id: The ID of the badge.
        :param str label: (optional) The name of the badge.
        :param str description: (optional) The description of the badge.
        :param CloudBadgeLearnMoreLinks learn_more_links: (optional)
        :param str get_started_link: (optional) An url to get started with the
               validation against this certification.
        :param str tag: (optional) Deprecated, will be removed.
        """
        self.id = id
        self.label = label
        self.description = description
        self.learn_more_links = learn_more_links
        self.get_started_link = get_started_link
        self.tag = tag

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CloudBadge':
        """Initialize a CloudBadge object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in CloudBadge JSON')
        if 'label' in _dict:
            args['label'] = _dict.get('label')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'learnMoreLinks' in _dict:
            args['learn_more_links'] = CloudBadgeLearnMoreLinks.from_dict(_dict.get('learnMoreLinks'))
        if 'getStartedLink' in _dict:
            args['get_started_link'] = _dict.get('getStartedLink')
        if 'tag' in _dict:
            args['tag'] = _dict.get('tag')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CloudBadge object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'label') and self.label is not None:
            _dict['label'] = self.label
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'learn_more_links') and self.learn_more_links is not None:
            _dict['learnMoreLinks'] = self.learn_more_links.to_dict()
        if hasattr(self, 'get_started_link') and self.get_started_link is not None:
            _dict['getStartedLink'] = self.get_started_link
        if hasattr(self, 'tag') and self.tag is not None:
            _dict['tag'] = self.tag
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CloudBadge object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CloudBadge') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CloudBadge') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CloudBadgeLearnMoreLinks():
    """
    CloudBadgeLearnMoreLinks.

    :attr str first_party: (optional) An url where first party (IBMer) vendors can
          learn more about this badge.
    :attr str third_party: (optional) An url where third party (non-IBMer) vendors
          can learn more about this badge.
    """

    def __init__(self,
                 *,
                 first_party: str = None,
                 third_party: str = None) -> None:
        """
        Initialize a CloudBadgeLearnMoreLinks object.

        :param str first_party: (optional) An url where first party (IBMer) vendors
               can learn more about this badge.
        :param str third_party: (optional) An url where third party (non-IBMer)
               vendors can learn more about this badge.
        """
        self.first_party = first_party
        self.third_party = third_party

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CloudBadgeLearnMoreLinks':
        """Initialize a CloudBadgeLearnMoreLinks object from a json dictionary."""
        args = {}
        if 'firstParty' in _dict:
            args['first_party'] = _dict.get('firstParty')
        if 'thirdParty' in _dict:
            args['third_party'] = _dict.get('thirdParty')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CloudBadgeLearnMoreLinks object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'first_party') and self.first_party is not None:
            _dict['firstParty'] = self.first_party
        if hasattr(self, 'third_party') and self.third_party is not None:
            _dict['thirdParty'] = self.third_party
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CloudBadgeLearnMoreLinks object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CloudBadgeLearnMoreLinks') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CloudBadgeLearnMoreLinks') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CreatePlanResponse():
    """
    CreatePlanResponse.

    :attr List[License] plans: (optional)
    """

    def __init__(self,
                 *,
                 plans: List['License'] = None) -> None:
        """
        Initialize a CreatePlanResponse object.

        :param List[License] plans: (optional)
        """
        self.plans = plans

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CreatePlanResponse':
        """Initialize a CreatePlanResponse object from a json dictionary."""
        args = {}
        if 'plans' in _dict:
            args['plans'] = [License.from_dict(x) for x in _dict.get('plans')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CreatePlanResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'plans') and self.plans is not None:
            _dict['plans'] = [x.to_dict() for x in self.plans]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CreatePlanResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CreatePlanResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CreatePlanResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class DeprecatePending():
    """
    The deprecation process of the product is in the pending state.

    :attr str deprecate_date: (optional) The time when the product was deprecated in
          standard ISO 8601 format.
    :attr str deprecate_state: (optional) The deprecation state of the product.
    :attr str description: (optional) The reason why the product is getting
          deprecated.
    """

    def __init__(self,
                 *,
                 deprecate_date: str = None,
                 deprecate_state: str = None,
                 description: str = None) -> None:
        """
        Initialize a DeprecatePending object.

        :param str deprecate_date: (optional) The time when the product was
               deprecated in standard ISO 8601 format.
        :param str deprecate_state: (optional) The deprecation state of the
               product.
        :param str description: (optional) The reason why the product is getting
               deprecated.
        """
        self.deprecate_date = deprecate_date
        self.deprecate_state = deprecate_state
        self.description = description

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'DeprecatePending':
        """Initialize a DeprecatePending object from a json dictionary."""
        args = {}
        if 'deprecateDate' in _dict:
            args['deprecate_date'] = _dict.get('deprecateDate')
        if 'deprecateState' in _dict:
            args['deprecate_state'] = _dict.get('deprecateState')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a DeprecatePending object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'deprecate_date') and self.deprecate_date is not None:
            _dict['deprecateDate'] = self.deprecate_date
        if hasattr(self, 'deprecate_state') and self.deprecate_state is not None:
            _dict['deprecateState'] = self.deprecate_state
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this DeprecatePending object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'DeprecatePending') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'DeprecatePending') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class Error():
    """
    Error.

    :attr str message: (optional) Describes the error.
    :attr ErrorExtensions extensions: (optional) These details are used to help the
          support engineer troubleshoot any occurring issues.
    """

    def __init__(self,
                 *,
                 message: str = None,
                 extensions: 'ErrorExtensions' = None) -> None:
        """
        Initialize a Error object.

        :param str message: (optional) Describes the error.
        :param ErrorExtensions extensions: (optional) These details are used to
               help the support engineer troubleshoot any occurring issues.
        """
        self.message = message
        self.extensions = extensions

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Error':
        """Initialize a Error object from a json dictionary."""
        args = {}
        if 'message' in _dict:
            args['message'] = _dict.get('message')
        if 'extensions' in _dict:
            args['extensions'] = ErrorExtensions.from_dict(_dict.get('extensions'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Error object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'message') and self.message is not None:
            _dict['message'] = self.message
        if hasattr(self, 'extensions') and self.extensions is not None:
            _dict['extensions'] = self.extensions.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Error object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Error') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Error') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ErrorExtensions():
    """
    These details are used to help the support engineer troubleshoot any occurring issues.

    :attr str code: (optional) The code that identifies the error.
    :attr str service_name: (optional) The programmatic name of the product. This is
          the unique ID of the product that is used within all IBM services and tools.
    :attr object exception: (optional) The occurring error.
    :attr str trid: (optional) The transaction ID. This ID can be used for
          identifying errors.
    :attr str operation_name: (optional) The opreation when the error occurred.
    """

    def __init__(self,
                 *,
                 code: str = None,
                 service_name: str = None,
                 exception: object = None,
                 trid: str = None,
                 operation_name: str = None) -> None:
        """
        Initialize a ErrorExtensions object.

        :param str code: (optional) The code that identifies the error.
        :param str service_name: (optional) The programmatic name of the product.
               This is the unique ID of the product that is used within all IBM services
               and tools.
        :param object exception: (optional) The occurring error.
        :param str trid: (optional) The transaction ID. This ID can be used for
               identifying errors.
        :param str operation_name: (optional) The opreation when the error
               occurred.
        """
        self.code = code
        self.service_name = service_name
        self.exception = exception
        self.trid = trid
        self.operation_name = operation_name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ErrorExtensions':
        """Initialize a ErrorExtensions object from a json dictionary."""
        args = {}
        if 'code' in _dict:
            args['code'] = _dict.get('code')
        if 'serviceName' in _dict:
            args['service_name'] = _dict.get('serviceName')
        if 'exception' in _dict:
            args['exception'] = _dict.get('exception')
        if 'trid' in _dict:
            args['trid'] = _dict.get('trid')
        if 'operationName' in _dict:
            args['operation_name'] = _dict.get('operationName')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ErrorExtensions object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'code') and self.code is not None:
            _dict['code'] = self.code
        if hasattr(self, 'service_name') and self.service_name is not None:
            _dict['serviceName'] = self.service_name
        if hasattr(self, 'exception') and self.exception is not None:
            _dict['exception'] = self.exception
        if hasattr(self, 'trid') and self.trid is not None:
            _dict['trid'] = self.trid
        if hasattr(self, 'operation_name') and self.operation_name is not None:
            _dict['operationName'] = self.operation_name
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ErrorExtensions object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ErrorExtensions') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ErrorExtensions') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class EscalationContactsUpdate():
    """
    The direct contact for IBM Cloud Support leaders to communicate with the support
    leader of your product. This contact information is not displayed on the product
    detail page in the catalog.

    :attr str email: (optional) The email address of the support leader.
    :attr str name: (optional) The name of the support leader.
    """

    def __init__(self,
                 *,
                 email: str = None,
                 name: str = None) -> None:
        """
        Initialize a EscalationContactsUpdate object.

        :param str email: (optional) The email address of the support leader.
        :param str name: (optional) The name of the support leader.
        """
        self.email = email
        self.name = name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'EscalationContactsUpdate':
        """Initialize a EscalationContactsUpdate object from a json dictionary."""
        args = {}
        if 'email' in _dict:
            args['email'] = _dict.get('email')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a EscalationContactsUpdate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'email') and self.email is not None:
            _dict['email'] = self.email
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this EscalationContactsUpdate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'EscalationContactsUpdate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'EscalationContactsUpdate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class HighlightSection():
    """
    The attributes of the product that differentiate it in the market.

    :attr str description: (optional) The description about the features of the
          product.
    :attr object description_i18n: (optional) The description about the features of
          the product in translation.
    :attr str title: (optional) The descriptive title for the feature.
    :attr object title_i18n: (optional) The descriptive title for the feature in
          translation.
    """

    def __init__(self,
                 *,
                 description: str = None,
                 description_i18n: object = None,
                 title: str = None,
                 title_i18n: object = None) -> None:
        """
        Initialize a HighlightSection object.

        :param str description: (optional) The description about the features of
               the product.
        :param object description_i18n: (optional) The description about the
               features of the product in translation.
        :param str title: (optional) The descriptive title for the feature.
        :param object title_i18n: (optional) The descriptive title for the feature
               in translation.
        """
        self.description = description
        self.description_i18n = description_i18n
        self.title = title
        self.title_i18n = title_i18n

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'HighlightSection':
        """Initialize a HighlightSection object from a json dictionary."""
        args = {}
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'description_i18n' in _dict:
            args['description_i18n'] = _dict.get('description_i18n')
        if 'title' in _dict:
            args['title'] = _dict.get('title')
        if 'title_i18n' in _dict:
            args['title_i18n'] = _dict.get('title_i18n')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a HighlightSection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'description_i18n') and self.description_i18n is not None:
            _dict['description_i18n'] = self.description_i18n
        if hasattr(self, 'title') and self.title is not None:
            _dict['title'] = self.title
        if hasattr(self, 'title_i18n') and self.title_i18n is not None:
            _dict['title_i18n'] = self.title_i18n
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this HighlightSection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'HighlightSection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'HighlightSection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class HighlightSectionInput():
    """
    The attributes of the product that differentiate it in the market.

    :attr str description: (optional) The description about the features of the
          product.
    :attr str title: (optional) The descriptive title for the feature.
    """

    def __init__(self,
                 *,
                 description: str = None,
                 title: str = None) -> None:
        """
        Initialize a HighlightSectionInput object.

        :param str description: (optional) The description about the features of
               the product.
        :param str title: (optional) The descriptive title for the feature.
        """
        self.description = description
        self.title = title

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'HighlightSectionInput':
        """Initialize a HighlightSectionInput object from a json dictionary."""
        args = {}
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'title' in _dict:
            args['title'] = _dict.get('title')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a HighlightSectionInput object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'title') and self.title is not None:
            _dict['title'] = self.title
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this HighlightSectionInput object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'HighlightSectionInput') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'HighlightSectionInput') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class HistoryItem():
    """
    HistoryItem.

    :attr str at: The time when you requested approval.
    :attr str display_name: (optional) The name of the user, who managed the
          approval request.
    :attr str event: (optional) The event that happened during the approval request.
    :attr str reason: (optional) The message from IBM Cloud approvers about the
          state of the approval request.
    :attr str username: (optional) The email address of the user.
    """

    def __init__(self,
                 at: str,
                 *,
                 display_name: str = None,
                 event: str = None,
                 reason: str = None,
                 username: str = None) -> None:
        """
        Initialize a HistoryItem object.

        :param str at: The time when you requested approval.
        :param str display_name: (optional) The name of the user, who managed the
               approval request.
        :param str event: (optional) The event that happened during the approval
               request.
        :param str reason: (optional) The message from IBM Cloud approvers about
               the state of the approval request.
        :param str username: (optional) The email address of the user.
        """
        self.at = at
        self.display_name = display_name
        self.event = event
        self.reason = reason
        self.username = username

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'HistoryItem':
        """Initialize a HistoryItem object from a json dictionary."""
        args = {}
        if 'at' in _dict:
            args['at'] = _dict.get('at')
        else:
            raise ValueError('Required property \'at\' not present in HistoryItem JSON')
        if 'displayName' in _dict:
            args['display_name'] = _dict.get('displayName')
        if 'event' in _dict:
            args['event'] = _dict.get('event')
        if 'reason' in _dict:
            args['reason'] = _dict.get('reason')
        if 'username' in _dict:
            args['username'] = _dict.get('username')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a HistoryItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'at') and self.at is not None:
            _dict['at'] = self.at
        if hasattr(self, 'display_name') and self.display_name is not None:
            _dict['displayName'] = self.display_name
        if hasattr(self, 'event') and self.event is not None:
            _dict['event'] = self.event
        if hasattr(self, 'reason') and self.reason is not None:
            _dict['reason'] = self.reason
        if hasattr(self, 'username') and self.username is not None:
            _dict['username'] = self.username
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this HistoryItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'HistoryItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'HistoryItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class License():
    """
    The pricing model for your product.

    :attr str description: The description of the pricing model.
    :attr str id: The ID of the pricing plan. This ID can be used for further
          pricing plan updates.
    :attr str label: The name of the pricing plan.
    :attr str type: The type of the pricing plan.
    :attr str url: The URL to where your customers can purchase the license that is
          required to use your product.
    """

    def __init__(self,
                 description: str,
                 id: str,
                 label: str,
                 type: str,
                 url: str) -> None:
        """
        Initialize a License object.

        :param str description: The description of the pricing model.
        :param str id: The ID of the pricing plan. This ID can be used for further
               pricing plan updates.
        :param str label: The name of the pricing plan.
        :param str type: The type of the pricing plan.
        :param str url: The URL to where your customers can purchase the license
               that is required to use your product.
        """
        self.description = description
        self.id = id
        self.label = label
        self.type = type
        self.url = url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'License':
        """Initialize a License object from a json dictionary."""
        args = {}
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        else:
            raise ValueError('Required property \'description\' not present in License JSON')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in License JSON')
        if 'label' in _dict:
            args['label'] = _dict.get('label')
        else:
            raise ValueError('Required property \'label\' not present in License JSON')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        else:
            raise ValueError('Required property \'type\' not present in License JSON')
        if 'url' in _dict:
            args['url'] = _dict.get('url')
        else:
            raise ValueError('Required property \'url\' not present in License JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a License object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'label') and self.label is not None:
            _dict['label'] = self.label
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'url') and self.url is not None:
            _dict['url'] = self.url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this License object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'License') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'License') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        The type of the pricing plan.
        """
        BYOL = 'byol'


class ListPlansResponse():
    """
    ListPlansResponse.

    :attr List[License] plans: (optional)
    """

    def __init__(self,
                 *,
                 plans: List['License'] = None) -> None:
        """
        Initialize a ListPlansResponse object.

        :param List[License] plans: (optional)
        """
        self.plans = plans

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ListPlansResponse':
        """Initialize a ListPlansResponse object from a json dictionary."""
        args = {}
        if 'plans' in _dict:
            args['plans'] = [License.from_dict(x) for x in _dict.get('plans')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ListPlansResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'plans') and self.plans is not None:
            _dict['plans'] = [x.to_dict() for x in self.plans]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ListPlansResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ListPlansResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ListPlansResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ListProductApprovalsResponse():
    """
    ListProductApprovalsResponse.

    :attr List[Resource] approvals: (optional)
    """

    def __init__(self,
                 *,
                 approvals: List['Resource'] = None) -> None:
        """
        Initialize a ListProductApprovalsResponse object.

        :param List[Resource] approvals: (optional)
        """
        self.approvals = approvals

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ListProductApprovalsResponse':
        """Initialize a ListProductApprovalsResponse object from a json dictionary."""
        args = {}
        if 'approvals' in _dict:
            args['approvals'] = [Resource.from_dict(x) for x in _dict.get('approvals')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ListProductApprovalsResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'approvals') and self.approvals is not None:
            _dict['approvals'] = [x.to_dict() for x in self.approvals]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ListProductApprovalsResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ListProductApprovalsResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ListProductApprovalsResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ListProductsResponse():
    """
    ListProductsResponse.

    :attr List[Error] errors: (optional)
    :attr List[ProductDetails] products: (optional)
    """

    def __init__(self,
                 *,
                 errors: List['Error'] = None,
                 products: List['ProductDetails'] = None) -> None:
        """
        Initialize a ListProductsResponse object.

        :param List[Error] errors: (optional)
        :param List[ProductDetails] products: (optional)
        """
        self.errors = errors
        self.products = products

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ListProductsResponse':
        """Initialize a ListProductsResponse object from a json dictionary."""
        args = {}
        if 'errors' in _dict:
            args['errors'] = [Error.from_dict(x) for x in _dict.get('errors')]
        if 'products' in _dict:
            args['products'] = [ProductDetails.from_dict(x) for x in _dict.get('products')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ListProductsResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'errors') and self.errors is not None:
            _dict['errors'] = [x.to_dict() for x in self.errors]
        if hasattr(self, 'products') and self.products is not None:
            _dict['products'] = [x.to_dict() for x in self.products]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ListProductsResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ListProductsResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ListProductsResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ListSupportChangeRequestsResponse():
    """
    ListSupportChangeRequestsResponse.

    :attr List[ChangeRequest] changes: (optional)
    """

    def __init__(self,
                 *,
                 changes: List['ChangeRequest'] = None) -> None:
        """
        Initialize a ListSupportChangeRequestsResponse object.

        :param List[ChangeRequest] changes: (optional)
        """
        self.changes = changes

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ListSupportChangeRequestsResponse':
        """Initialize a ListSupportChangeRequestsResponse object from a json dictionary."""
        args = {}
        if 'changes' in _dict:
            args['changes'] = [ChangeRequest.from_dict(x) for x in _dict.get('changes')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ListSupportChangeRequestsResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'changes') and self.changes is not None:
            _dict['changes'] = [x.to_dict() for x in self.changes]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ListSupportChangeRequestsResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ListSupportChangeRequestsResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ListSupportChangeRequestsResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class MediaSection():
    """
    MediaSection.

    :attr str caption: Provide a brief explanation that indicates what the media
          illustrates. This caption is displayed in the catalog.
    :attr object caption_i18n: (optional) The brief explanation for your images and
          videos in translation.
    :attr str thumbnail: (optional) The reduced-size version of your images and
          videos.
    :attr str type: The type of the media.
    :attr str url: The URL that links to the media that shows off the product.
    """

    def __init__(self,
                 caption: str,
                 type: str,
                 url: str,
                 *,
                 caption_i18n: object = None,
                 thumbnail: str = None) -> None:
        """
        Initialize a MediaSection object.

        :param str caption: Provide a brief explanation that indicates what the
               media illustrates. This caption is displayed in the catalog.
        :param str type: The type of the media.
        :param str url: The URL that links to the media that shows off the product.
        :param object caption_i18n: (optional) The brief explanation for your
               images and videos in translation.
        :param str thumbnail: (optional) The reduced-size version of your images
               and videos.
        """
        self.caption = caption
        self.caption_i18n = caption_i18n
        self.thumbnail = thumbnail
        self.type = type
        self.url = url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'MediaSection':
        """Initialize a MediaSection object from a json dictionary."""
        args = {}
        if 'caption' in _dict:
            args['caption'] = _dict.get('caption')
        else:
            raise ValueError('Required property \'caption\' not present in MediaSection JSON')
        if 'caption_i18n' in _dict:
            args['caption_i18n'] = _dict.get('caption_i18n')
        if 'thumbnail' in _dict:
            args['thumbnail'] = _dict.get('thumbnail')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        else:
            raise ValueError('Required property \'type\' not present in MediaSection JSON')
        if 'url' in _dict:
            args['url'] = _dict.get('url')
        else:
            raise ValueError('Required property \'url\' not present in MediaSection JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a MediaSection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'caption') and self.caption is not None:
            _dict['caption'] = self.caption
        if hasattr(self, 'caption_i18n') and self.caption_i18n is not None:
            _dict['caption_i18n'] = self.caption_i18n
        if hasattr(self, 'thumbnail') and self.thumbnail is not None:
            _dict['thumbnail'] = self.thumbnail
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'url') and self.url is not None:
            _dict['url'] = self.url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this MediaSection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'MediaSection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'MediaSection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        The type of the media.
        """
        IMAGE = 'image'
        YOUTUBE = 'youtube'
        VIDEO_MP4 = 'video/mp4'
        VIDEO_WEBM = 'video/webm'


class MediaSectionInput():
    """
    MediaSectionInput.

    :attr str caption: Provide a brief explanation that indicates what the media
          illustrates. This caption is displayed in the catalog.
    :attr str thumbnail: (optional) The reduced-size version of your images and
          videos.
    :attr str type: The type of the media.
    :attr str url: The URL that links to the media that shows off the product.
    """

    def __init__(self,
                 caption: str,
                 type: str,
                 url: str,
                 *,
                 thumbnail: str = None) -> None:
        """
        Initialize a MediaSectionInput object.

        :param str caption: Provide a brief explanation that indicates what the
               media illustrates. This caption is displayed in the catalog.
        :param str type: The type of the media.
        :param str url: The URL that links to the media that shows off the product.
        :param str thumbnail: (optional) The reduced-size version of your images
               and videos.
        """
        self.caption = caption
        self.thumbnail = thumbnail
        self.type = type
        self.url = url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'MediaSectionInput':
        """Initialize a MediaSectionInput object from a json dictionary."""
        args = {}
        if 'caption' in _dict:
            args['caption'] = _dict.get('caption')
        else:
            raise ValueError('Required property \'caption\' not present in MediaSectionInput JSON')
        if 'thumbnail' in _dict:
            args['thumbnail'] = _dict.get('thumbnail')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        else:
            raise ValueError('Required property \'type\' not present in MediaSectionInput JSON')
        if 'url' in _dict:
            args['url'] = _dict.get('url')
        else:
            raise ValueError('Required property \'url\' not present in MediaSectionInput JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a MediaSectionInput object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'caption') and self.caption is not None:
            _dict['caption'] = self.caption
        if hasattr(self, 'thumbnail') and self.thumbnail is not None:
            _dict['thumbnail'] = self.thumbnail
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'url') and self.url is not None:
            _dict['url'] = self.url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this MediaSectionInput object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'MediaSectionInput') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'MediaSectionInput') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        The type of the media.
        """
        IMAGE = 'image'
        YOUTUBE = 'youtube'
        VIDEO_MP4 = 'video/mp4'
        VIDEO_WEBM = 'video/webm'


class ProductDetails():
    """
    The details of the product.

    :attr str account_id: (optional) The unique ID for the account in which the
          product is being onboarded.
    :attr str created_at: (optional) The time when the new product was created in
          standard ISO 8601 format.
    :attr str id: (optional) The ID that uniquely identifies the product in Partner
          Center. This ID can be found on the Dashboard tab in Partner Center.
    :attr bool material_agreement: (optional) The confirmation that your company is
          authorized to use all materials.
    :attr str product_type: (optional) The type of the product that you want to
          onboard to IBM Cloud.
    :attr str product_name: (optional) The name of the product that you are
          onboarding. This name is displayed to users when you publish your product in the
          catalog.
    :attr str published_at: (optional) The time when the new product was published
          to the IBM Cloud catalog in standard ISO 8601 format.
    :attr str tax_assessment: (optional) The tax assessment for your product.
    :attr str updated_at: (optional) The time when the product was updated in
          standard ISO 8601 format.
    :attr List[ChangeRequest] change_requests: (optional)
    """

    def __init__(self,
                 *,
                 account_id: str = None,
                 created_at: str = None,
                 id: str = None,
                 material_agreement: bool = None,
                 product_type: str = None,
                 product_name: str = None,
                 published_at: str = None,
                 tax_assessment: str = None,
                 updated_at: str = None,
                 change_requests: List['ChangeRequest'] = None) -> None:
        """
        Initialize a ProductDetails object.

        :param str account_id: (optional) The unique ID for the account in which
               the product is being onboarded.
        :param str created_at: (optional) The time when the new product was created
               in standard ISO 8601 format.
        :param str id: (optional) The ID that uniquely identifies the product in
               Partner Center. This ID can be found on the Dashboard tab in Partner
               Center.
        :param bool material_agreement: (optional) The confirmation that your
               company is authorized to use all materials.
        :param str product_type: (optional) The type of the product that you want
               to onboard to IBM Cloud.
        :param str product_name: (optional) The name of the product that you are
               onboarding. This name is displayed to users when you publish your product
               in the catalog.
        :param str published_at: (optional) The time when the new product was
               published to the IBM Cloud catalog in standard ISO 8601 format.
        :param str tax_assessment: (optional) The tax assessment for your product.
        :param str updated_at: (optional) The time when the product was updated in
               standard ISO 8601 format.
        :param List[ChangeRequest] change_requests: (optional)
        """
        self.account_id = account_id
        self.created_at = created_at
        self.id = id
        self.material_agreement = material_agreement
        self.product_type = product_type
        self.product_name = product_name
        self.published_at = published_at
        self.tax_assessment = tax_assessment
        self.updated_at = updated_at
        self.change_requests = change_requests

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ProductDetails':
        """Initialize a ProductDetails object from a json dictionary."""
        args = {}
        if 'accountId' in _dict:
            args['account_id'] = _dict.get('accountId')
        if 'createdAt' in _dict:
            args['created_at'] = _dict.get('createdAt')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'materialAgreement' in _dict:
            args['material_agreement'] = _dict.get('materialAgreement')
        if 'productType' in _dict:
            args['product_type'] = _dict.get('productType')
        if 'productName' in _dict:
            args['product_name'] = _dict.get('productName')
        if 'publishedAt' in _dict:
            args['published_at'] = _dict.get('publishedAt')
        if 'taxAssessment' in _dict:
            args['tax_assessment'] = _dict.get('taxAssessment')
        if 'updatedAt' in _dict:
            args['updated_at'] = _dict.get('updatedAt')
        if 'changeRequests' in _dict:
            args['change_requests'] = [ChangeRequest.from_dict(x) for x in _dict.get('changeRequests')]
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ProductDetails object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'account_id') and self.account_id is not None:
            _dict['accountId'] = self.account_id
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['createdAt'] = self.created_at
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'material_agreement') and self.material_agreement is not None:
            _dict['materialAgreement'] = self.material_agreement
        if hasattr(self, 'product_type') and self.product_type is not None:
            _dict['productType'] = self.product_type
        if hasattr(self, 'product_name') and self.product_name is not None:
            _dict['productName'] = self.product_name
        if hasattr(self, 'published_at') and self.published_at is not None:
            _dict['publishedAt'] = self.published_at
        if hasattr(self, 'tax_assessment') and self.tax_assessment is not None:
            _dict['taxAssessment'] = self.tax_assessment
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updatedAt'] = self.updated_at
        if hasattr(self, 'change_requests') and self.change_requests is not None:
            _dict['changeRequests'] = [x.to_dict() for x in self.change_requests]
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ProductDetails object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ProductDetails') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ProductDetails') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ProductTypeEnum(str, Enum):
        """
        The type of the product that you want to onboard to IBM Cloud.
        """
        SOFTWARE = 'SOFTWARE'
        SOLUTION = 'SOLUTION'
        MODULE = 'MODULE'
        SERVICE = 'SERVICE'


    class TaxAssessmentEnum(str, Enum):
        """
        The tax assessment for your product.
        """
        SOFTWARE = 'SOFTWARE'
        SAAS = 'SAAS'
        IAAS = 'IAAS'
        PAAS = 'PAAS'


class Resource():
    """
    The details of the catalog listing approval request.

    :attr List[HistoryItem] history: (optional) Shows the details of the approval.
    :attr str id: The ID that uniquely identifies the product in Partner Center.
          This ID can be found on the Dashboard tab in Partner Center.
    :attr List[str] next_events: (optional) The events after requesting an approval.
    :attr State state: The state of the approval.
    """

    def __init__(self,
                 id: str,
                 state: 'State',
                 *,
                 history: List['HistoryItem'] = None,
                 next_events: List[str] = None) -> None:
        """
        Initialize a Resource object.

        :param str id: The ID that uniquely identifies the product in Partner
               Center. This ID can be found on the Dashboard tab in Partner Center.
        :param State state: The state of the approval.
        :param List[HistoryItem] history: (optional) Shows the details of the
               approval.
        :param List[str] next_events: (optional) The events after requesting an
               approval.
        """
        self.history = history
        self.id = id
        self.next_events = next_events
        self.state = state

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Resource':
        """Initialize a Resource object from a json dictionary."""
        args = {}
        if 'history' in _dict:
            args['history'] = [HistoryItem.from_dict(x) for x in _dict.get('history')]
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        else:
            raise ValueError('Required property \'id\' not present in Resource JSON')
        if 'nextEvents' in _dict:
            args['next_events'] = _dict.get('nextEvents')
        if 'state' in _dict:
            args['state'] = State.from_dict(_dict.get('state'))
        else:
            raise ValueError('Required property \'state\' not present in Resource JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Resource object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'history') and self.history is not None:
            _dict['history'] = [x.to_dict() for x in self.history]
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'next_events') and self.next_events is not None:
            _dict['nextEvents'] = self.next_events
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Resource object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Resource') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Resource') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class State():
    """
    The state of the approval.

    :attr str name: The name of the approval state.
    """

    def __init__(self,
                 name: str) -> None:
        """
        Initialize a State object.

        :param str name: The name of the approval state.
        """
        self.name = name

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'State':
        """Initialize a State object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in State JSON')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a State object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this State object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'State') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'State') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class NameEnum(str, Enum):
        """
        The name of the approval state.
        """
        WAITINGFORREQUESTFORREVIEW = 'waitingForRequestForReview'
        PENDINGAPPROVAL = 'pendingApproval'
        WAITINGFORPUBLISH = 'waitingForPublish'
        PUBLISHED = 'published'
        SUSPENDED = 'suspended'
        WAITINGFORDEPRECATIONAFTERSUSPENSION = 'waitingForDeprecationAfterSuspension'
        WAITINGFORDEPRECATION = 'waitingForDeprecation'
        DEPRECATED = 'deprecated'


class Support():
    """
    Provide details about how customers can get help when they are using your product.

    :attr List[str] locations: (optional) The locations where your support team is
          providing support from.
    :attr str process: (optional) Provide details about how and when customers can
          get in touch with your support team.
    :attr object process_i18n: (optional) Translated strings for the support process
          describing how and when customers can get in touch with your support team.
    :attr List[SupportDetails] support_details: (optional) Provide details for the
          available options for getting support. The details that you provide are
          displayed on your product details page in the catalog.
    :attr SupportEscalation support_escalation: (optional) The details about your
          support escalation process. The details that you provide are displayed on your
          product details page in the catalog.
    :attr str support_type: (optional) The provider type for support of your
          product.
    :attr str url: (optional) The support site URL where users can go to get help,
          answer their questions, or ask experts and the community for help.
    """

    def __init__(self,
                 *,
                 locations: List[str] = None,
                 process: str = None,
                 process_i18n: object = None,
                 support_details: List['SupportDetails'] = None,
                 support_escalation: 'SupportEscalation' = None,
                 support_type: str = None,
                 url: str = None) -> None:
        """
        Initialize a Support object.

        :param List[str] locations: (optional) The locations where your support
               team is providing support from.
        :param str process: (optional) Provide details about how and when customers
               can get in touch with your support team.
        :param object process_i18n: (optional) Translated strings for the support
               process describing how and when customers can get in touch with your
               support team.
        :param List[SupportDetails] support_details: (optional) Provide details for
               the available options for getting support. The details that you provide are
               displayed on your product details page in the catalog.
        :param SupportEscalation support_escalation: (optional) The details about
               your support escalation process. The details that you provide are displayed
               on your product details page in the catalog.
        :param str support_type: (optional) The provider type for support of your
               product.
        :param str url: (optional) The support site URL where users can go to get
               help, answer their questions, or ask experts and the community for help.
        """
        self.locations = locations
        self.process = process
        self.process_i18n = process_i18n
        self.support_details = support_details
        self.support_escalation = support_escalation
        self.support_type = support_type
        self.url = url

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Support':
        """Initialize a Support object from a json dictionary."""
        args = {}
        if 'locations' in _dict:
            args['locations'] = _dict.get('locations')
        if 'process' in _dict:
            args['process'] = _dict.get('process')
        if 'process_i18n' in _dict:
            args['process_i18n'] = _dict.get('process_i18n')
        if 'support_details' in _dict:
            args['support_details'] = [SupportDetails.from_dict(x) for x in _dict.get('support_details')]
        if 'support_escalation' in _dict:
            args['support_escalation'] = SupportEscalation.from_dict(_dict.get('support_escalation'))
        if 'support_type' in _dict:
            args['support_type'] = _dict.get('support_type')
        if 'url' in _dict:
            args['url'] = _dict.get('url')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Support object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'locations') and self.locations is not None:
            _dict['locations'] = self.locations
        if hasattr(self, 'process') and self.process is not None:
            _dict['process'] = self.process
        if hasattr(self, 'process_i18n') and self.process_i18n is not None:
            _dict['process_i18n'] = self.process_i18n
        if hasattr(self, 'support_details') and self.support_details is not None:
            _dict['support_details'] = [x.to_dict() for x in self.support_details]
        if hasattr(self, 'support_escalation') and self.support_escalation is not None:
            _dict['support_escalation'] = self.support_escalation.to_dict()
        if hasattr(self, 'support_type') and self.support_type is not None:
            _dict['support_type'] = self.support_type
        if hasattr(self, 'url') and self.url is not None:
            _dict['url'] = self.url
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Support object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Support') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Support') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SupportTypeEnum(str, Enum):
        """
        The provider type for support of your product.
        """
        THIRD_PARTY = 'third-party'
        COMMUNITY = 'community'


class SupportDetails():
    """
    Provide details about the available options for getting support. The details that you
    provide are displayed on your product details page in the catalog.

    :attr SupportDetailsAvailability availability: (optional) The details about the
          availability of your support service. At minimum, your support service must be
          available 8 hours a day, Monday through Friday.
    :attr str contact: (optional) Provide your support contact information. Don't
          include details with personal information, for example personal emails.
    :attr SupportResponseTimes response_wait_time: (optional) The minimum number of
          hours that it takes to update your customers about a support case.
    :attr str type: (optional) Provide information about how your customers can get
          support.
    """

    def __init__(self,
                 *,
                 availability: 'SupportDetailsAvailability' = None,
                 contact: str = None,
                 response_wait_time: 'SupportResponseTimes' = None,
                 type: str = None) -> None:
        """
        Initialize a SupportDetails object.

        :param SupportDetailsAvailability availability: (optional) The details
               about the availability of your support service. At minimum, your support
               service must be available 8 hours a day, Monday through Friday.
        :param str contact: (optional) Provide your support contact information.
               Don't include details with personal information, for example personal
               emails.
        :param SupportResponseTimes response_wait_time: (optional) The minimum
               number of hours that it takes to update your customers about a support
               case.
        :param str type: (optional) Provide information about how your customers
               can get support.
        """
        self.availability = availability
        self.contact = contact
        self.response_wait_time = response_wait_time
        self.type = type

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SupportDetails':
        """Initialize a SupportDetails object from a json dictionary."""
        args = {}
        if 'availability' in _dict:
            args['availability'] = SupportDetailsAvailability.from_dict(_dict.get('availability'))
        if 'contact' in _dict:
            args['contact'] = _dict.get('contact')
        if 'response_wait_time' in _dict:
            args['response_wait_time'] = SupportResponseTimes.from_dict(_dict.get('response_wait_time'))
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SupportDetails object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'availability') and self.availability is not None:
            _dict['availability'] = self.availability.to_dict()
        if hasattr(self, 'contact') and self.contact is not None:
            _dict['contact'] = self.contact
        if hasattr(self, 'response_wait_time') and self.response_wait_time is not None:
            _dict['response_wait_time'] = self.response_wait_time.to_dict()
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SupportDetails object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SupportDetails') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SupportDetails') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Provide information about how your customers can get support.
        """
        EMAIL = 'email'
        CHAT = 'chat'
        SLACK = 'slack'
        PHONE = 'phone'
        OTHER = 'other'


class SupportDetailsAvailability():
    """
    The details about the availability of your support service. At minimum, your support
    service must be available 8 hours a day, Monday through Friday.

    :attr bool always_available: (optional) Support is available at any time.
    :attr List[SupportDetailsAvailabilityTimes] times: (optional) The times when
          your support service is available for your customers.
    :attr str timezone: (optional) The timezone in which provided support is
          available.
    """

    def __init__(self,
                 *,
                 always_available: bool = None,
                 times: List['SupportDetailsAvailabilityTimes'] = None,
                 timezone: str = None) -> None:
        """
        Initialize a SupportDetailsAvailability object.

        :param bool always_available: (optional) Support is available at any time.
        :param List[SupportDetailsAvailabilityTimes] times: (optional) The times
               when your support service is available for your customers.
        :param str timezone: (optional) The timezone in which provided support is
               available.
        """
        self.always_available = always_available
        self.times = times
        self.timezone = timezone

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SupportDetailsAvailability':
        """Initialize a SupportDetailsAvailability object from a json dictionary."""
        args = {}
        if 'always_available' in _dict:
            args['always_available'] = _dict.get('always_available')
        if 'times' in _dict:
            args['times'] = [SupportDetailsAvailabilityTimes.from_dict(x) for x in _dict.get('times')]
        if 'timezone' in _dict:
            args['timezone'] = _dict.get('timezone')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SupportDetailsAvailability object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'always_available') and self.always_available is not None:
            _dict['always_available'] = self.always_available
        if hasattr(self, 'times') and self.times is not None:
            _dict['times'] = [x.to_dict() for x in self.times]
        if hasattr(self, 'timezone') and self.timezone is not None:
            _dict['timezone'] = self.timezone
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SupportDetailsAvailability object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SupportDetailsAvailability') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SupportDetailsAvailability') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SupportDetailsAvailabilityTimes():
    """
    The details about the availability of product support. At minimum, your support
    service must be available 8 hours a day, Monday through Friday.

    :attr int day: (optional) The days when your support service is available
          throughout the week. The seven days of the week are defined as numbers from 1 to
          7. If your support service is available on Mondays and Wednesdays, enter numbers
          1 and 3.
    :attr str end_time: (optional) The time in `hh:mm` format when support ends each
          day when your support coverage is listed as available.
    :attr str start_time: (optional) The time in `hh:mm` format when support starts
          each day when your support coverage is listed as available.
    """

    def __init__(self,
                 *,
                 day: int = None,
                 end_time: str = None,
                 start_time: str = None) -> None:
        """
        Initialize a SupportDetailsAvailabilityTimes object.

        :param int day: (optional) The days when your support service is available
               throughout the week. The seven days of the week are defined as numbers from
               1 to 7. If your support service is available on Mondays and Wednesdays,
               enter numbers 1 and 3.
        :param str end_time: (optional) The time in `hh:mm` format when support
               ends each day when your support coverage is listed as available.
        :param str start_time: (optional) The time in `hh:mm` format when support
               starts each day when your support coverage is listed as available.
        """
        self.day = day
        self.end_time = end_time
        self.start_time = start_time

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SupportDetailsAvailabilityTimes':
        """Initialize a SupportDetailsAvailabilityTimes object from a json dictionary."""
        args = {}
        if 'day' in _dict:
            args['day'] = _dict.get('day')
        if 'end_time' in _dict:
            args['end_time'] = _dict.get('end_time')
        if 'start_time' in _dict:
            args['start_time'] = _dict.get('start_time')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SupportDetailsAvailabilityTimes object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'day') and self.day is not None:
            _dict['day'] = self.day
        if hasattr(self, 'end_time') and self.end_time is not None:
            _dict['end_time'] = self.end_time
        if hasattr(self, 'start_time') and self.start_time is not None:
            _dict['start_time'] = self.start_time
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SupportDetailsAvailabilityTimes object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SupportDetailsAvailabilityTimes') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SupportDetailsAvailabilityTimes') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SupportEscalation():
    """
    The details about your support escalation process. The details that you provide are
    displayed on your product details page in the catalog.

    :attr str contact: (optional) The direct contact for IBM Cloud Support leaders
          to communicate with the support leaders of your product. This contact
          information is not displayed on the product details page in the catalog.
    :attr SupportEscalationTimes escalation_wait_time: (optional) The number of
          hours that your customers need to wait before escalating a case.
    :attr SupportResponseTimes response_wait_time: (optional) The minimum number of
          hours that it takes to update your customers about a support case.
    """

    def __init__(self,
                 *,
                 contact: str = None,
                 escalation_wait_time: 'SupportEscalationTimes' = None,
                 response_wait_time: 'SupportResponseTimes' = None) -> None:
        """
        Initialize a SupportEscalation object.

        :param str contact: (optional) The direct contact for IBM Cloud Support
               leaders to communicate with the support leaders of your product. This
               contact information is not displayed on the product details page in the
               catalog.
        :param SupportEscalationTimes escalation_wait_time: (optional) The number
               of hours that your customers need to wait before escalating a case.
        :param SupportResponseTimes response_wait_time: (optional) The minimum
               number of hours that it takes to update your customers about a support
               case.
        """
        self.contact = contact
        self.escalation_wait_time = escalation_wait_time
        self.response_wait_time = response_wait_time

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SupportEscalation':
        """Initialize a SupportEscalation object from a json dictionary."""
        args = {}
        if 'contact' in _dict:
            args['contact'] = _dict.get('contact')
        if 'escalation_wait_time' in _dict:
            args['escalation_wait_time'] = SupportEscalationTimes.from_dict(_dict.get('escalation_wait_time'))
        if 'response_wait_time' in _dict:
            args['response_wait_time'] = SupportResponseTimes.from_dict(_dict.get('response_wait_time'))
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SupportEscalation object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'contact') and self.contact is not None:
            _dict['contact'] = self.contact
        if hasattr(self, 'escalation_wait_time') and self.escalation_wait_time is not None:
            _dict['escalation_wait_time'] = self.escalation_wait_time.to_dict()
        if hasattr(self, 'response_wait_time') and self.response_wait_time is not None:
            _dict['response_wait_time'] = self.response_wait_time.to_dict()
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SupportEscalation object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SupportEscalation') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SupportEscalation') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SupportEscalationTimes():
    """
    The number of hours that your customers need to wait before escalating a case.

    :attr str type: (optional)
    :attr int value: (optional) The amount of hours.
    """

    def __init__(self,
                 *,
                 type: str = None,
                 value: int = None) -> None:
        """
        Initialize a SupportEscalationTimes object.

        :param str type: (optional)
        :param int value: (optional) The amount of hours.
        """
        self.type = type
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SupportEscalationTimes':
        """Initialize a SupportEscalationTimes object from a json dictionary."""
        args = {}
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SupportEscalationTimes object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SupportEscalationTimes object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SupportEscalationTimes') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SupportEscalationTimes') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        type.
        """
        HOUR = 'hour'


class SupportResponseTimes():
    """
    The minimum number of hours that it takes to update your customers about a support
    case.

    :attr str type: (optional)
    :attr int value: (optional) The amount of hours.
    """

    def __init__(self,
                 *,
                 type: str = None,
                 value: int = None) -> None:
        """
        Initialize a SupportResponseTimes object.

        :param str type: (optional)
        :param int value: (optional) The amount of hours.
        """
        self.type = type
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SupportResponseTimes':
        """Initialize a SupportResponseTimes object from a json dictionary."""
        args = {}
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SupportResponseTimes object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SupportResponseTimes object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SupportResponseTimes') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SupportResponseTimes') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        type.
        """
        HOUR = 'hour'

